From f974fe5502a7282dbae3646ca43995bdce24320b Mon Sep 17 00:00:00 2001
From: Jonas Berlin <jonas.berlin@nitorcreations.com>
Date: Mon, 7 Oct 2013 09:25:45 +0300
Subject: [PATCH] Add ClassPathAdjuster interface and @UseClassPathAdjuster
 annotation which enable adjusting the mocking classloader's classpath. This
 was introduced to be able to provide the mocking classloader with the bytes
 of test classes dynamically created at runtime (which the mocking classloader
 needs to instrument the classes).

---
 .../core/classloader/ClassPathAdjuster.java        | 29 +++++++++
 .../core/classloader/MockClassLoader.java          | 36 ++++++++++-
 .../annotations/UseClassPathAdjuster.java          | 33 ++++++++++
 .../utils/impl/AbstractTestSuiteChunkerImpl.java   |  3 +-
 .../core/classloader/MockClassLoaderTest.java      | 72 ++++++++++++++++++++++
 5 files changed, 170 insertions(+), 3 deletions(-)
 create mode 100644 core/src/main/java/org/powermock/core/classloader/ClassPathAdjuster.java
 create mode 100644 core/src/main/java/org/powermock/core/classloader/annotations/UseClassPathAdjuster.java

diff --git core/src/main/java/org/powermock/core/classloader/ClassPathAdjuster.java core/src/main/java/org/powermock/core/classloader/ClassPathAdjuster.java
new file mode 100644
index 0000000..c81328f
--- /dev/null
+++ core/src/main/java/org/powermock/core/classloader/ClassPathAdjuster.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2013 Jonas Berlin
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.powermock.core.classloader;
+
+import javassist.ClassPool;
+
+import org.powermock.core.classloader.annotations.UseClassPathAdjuster;
+
+/**
+ * This interface can be used to adjust the classpath used by powermock to locate
+ * class files. Use the @{@link UseClassPathAdjuster} to activate.
+ */
+public interface ClassPathAdjuster {
+    void adjustClassPath(ClassPool classPool);
+}
diff --git core/src/main/java/org/powermock/core/classloader/MockClassLoader.java core/src/main/java/org/powermock/core/classloader/MockClassLoader.java
index 72e3d67..d7b1fa6 100644
--- core/src/main/java/org/powermock/core/classloader/MockClassLoader.java
+++ core/src/main/java/org/powermock/core/classloader/MockClassLoader.java
@@ -20,6 +20,7 @@ import javassist.ClassPool;
 import javassist.CtClass;
 import org.powermock.core.ClassReplicaCreator;
 import org.powermock.core.WildcardMatcher;
+import org.powermock.core.classloader.annotations.UseClassPathAdjuster;
 import org.powermock.core.spi.PowerMockPolicy;
 import org.powermock.core.spi.support.InvocationSubstitute;
 import org.powermock.core.transformers.MockTransformer;
@@ -85,11 +86,20 @@ public final class MockClassLoader extends DeferSupportingClassLoader {
      * @param packagesToDefer Classes in these packages will be defered to the system
      *                        class-loader.
      */
-    public MockClassLoader(String[] classesToMock, String[] packagesToDefer) {
+    public MockClassLoader(String[] classesToMock, String[] packagesToDefer, UseClassPathAdjuster useClassPathAdjuster) {
         super(MockClassLoader.class.getClassLoader(), getPackagesToDefer(packagesToDefer));
 
         addClassesToModify(classesToMock);
         classPool.appendClassPath(new ClassClassPath(this.getClass()));
+        if (useClassPathAdjuster != null) {
+            try {
+                Class<? extends ClassPathAdjuster> value = useClassPathAdjuster.value();
+                ClassPathAdjuster classPathAdjuster = value.newInstance();
+                classPathAdjuster.adjustClassPath(classPool);
+            } catch (ReflectiveOperationException e) {
+                throw new RuntimeException("Error instantiating class path adjuster", e);
+            }
+        }
     }
 
     private static String[] getPackagesToDefer(final String[] additionalDeferPackages) {
@@ -109,10 +119,32 @@ public final class MockClassLoader extends DeferSupportingClassLoader {
      * Creates a new instance of the {@link MockClassLoader} based on the
      * following parameters:
      *
+     * @param classesToMock   The classes that must be modified to prepare for testability.
+     * @param packagesToDefer Classes in these packages will be defered to the system
+     *                        class-loader.
+     */
+    public MockClassLoader(String[] classesToMock, String[] packagesToDefer) {
+        this(classesToMock, packagesToDefer, null);
+    }
+
+    /**
+     * Creates a new instance of the {@link MockClassLoader} based on the
+     * following parameters:
+     *
+     * @param classesToMock The classes that must be modified to prepare for testability.
+     */
+    public MockClassLoader(String[] classesToMock, UseClassPathAdjuster useClassPathAdjuster) {
+        this(classesToMock, new String[0], useClassPathAdjuster);
+    }
+
+    /**
+     * Creates a new instance of the {@link MockClassLoader} based on the
+     * following parameters:
+     *
      * @param classesToMock The classes that must be modified to prepare for testability.
      */
     public MockClassLoader(String[] classesToMock) {
-        this(classesToMock, new String[0]);
+        this(classesToMock, new String[0], null);
     }
 
     /**
diff --git core/src/main/java/org/powermock/core/classloader/annotations/UseClassPathAdjuster.java core/src/main/java/org/powermock/core/classloader/annotations/UseClassPathAdjuster.java
new file mode 100644
index 0000000..1b8e362
--- /dev/null
+++ core/src/main/java/org/powermock/core/classloader/annotations/UseClassPathAdjuster.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2013 Jonas Berlin
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.powermock.core.classloader.annotations;
+
+import java.lang.annotation.*;
+
+import org.powermock.core.classloader.ClassPathAdjuster;
+
+/**
+ * Use this annotation to enable adjusting of the class path used by powermock
+ * to locate class files.
+ */
+@Target( { ElementType.TYPE, ElementType.METHOD })
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+@Inherited
+public @interface UseClassPathAdjuster {
+    Class<? extends ClassPathAdjuster>  value();
+}
diff --git core/src/main/java/org/powermock/tests/utils/impl/AbstractTestSuiteChunkerImpl.java core/src/main/java/org/powermock/tests/utils/impl/AbstractTestSuiteChunkerImpl.java
index 5672b0d..dfb3ca7 100644
--- core/src/main/java/org/powermock/tests/utils/impl/AbstractTestSuiteChunkerImpl.java
+++ core/src/main/java/org/powermock/tests/utils/impl/AbstractTestSuiteChunkerImpl.java
@@ -195,9 +195,10 @@ public abstract class AbstractTestSuiteChunkerImpl<T> implements TestSuiteChunke
             List<MockTransformer> mockTransformerChain = new ArrayList<MockTransformer>();
             final MainMockTransformer mainMockTransformer = new MainMockTransformer();
             mockTransformerChain.add(mainMockTransformer);
+            final UseClassPathAdjuster useClassPathAdjuster = testClass.getAnnotation(UseClassPathAdjuster.class);
             mockLoader = AccessController.doPrivileged(new PrivilegedAction<MockClassLoader>() {
                 public MockClassLoader run() {
-                    return new MockClassLoader(classesToLoadByMockClassloader, packagesToIgnore);
+                    return new MockClassLoader(classesToLoadByMockClassloader, packagesToIgnore, useClassPathAdjuster);
                 }
             });
             MockClassLoader mockClassLoader = (MockClassLoader) mockLoader;
diff --git core/src/test/java/org/powermock/core/classloader/MockClassLoaderTest.java core/src/test/java/org/powermock/core/classloader/MockClassLoaderTest.java
index a8bd5d8..6eca6da 100644
--- core/src/test/java/org/powermock/core/classloader/MockClassLoaderTest.java
+++ core/src/test/java/org/powermock/core/classloader/MockClassLoaderTest.java
@@ -16,17 +16,27 @@
 package org.powermock.core.classloader;
 
 import junit.framework.Assert;
+
+import org.junit.Ignore;
 import org.junit.Test;
+import org.powermock.core.classloader.annotations.UseClassPathAdjuster;
 import org.powermock.core.transformers.MockTransformer;
 import org.powermock.core.transformers.impl.MainMockTransformer;
 import org.powermock.reflect.Whitebox;
 
+import java.io.FileOutputStream;
+import java.lang.annotation.Annotation;
 import java.net.URL;
 import java.net.URLClassLoader;
 import java.util.Enumeration;
 import java.util.LinkedList;
 import java.util.List;
 
+import javassist.ByteArrayClassPath;
+import javassist.CannotCompileException;
+import javassist.ClassPool;
+import javassist.CtClass;
+
 import static org.junit.Assert.*;
 import static org.powermock.core.classloader.MockClassLoader.MODIFY_ALL_CLASSES;
 
@@ -129,4 +139,66 @@ public class MockClassLoaderTest {
         Assert.assertTrue(resource.getPath().endsWith("test.txt"));
         Assert.assertFalse(resources.hasMoreElements());
     }
+    
+    @Test
+    public void canFindDynamicClassFromAdjustedClasspath() throws Exception {
+        // Construct MockClassLoader with @UseClassPathAdjuster annotation.
+        // It activates our MyClassPathAdjuster class which appends our dynamic
+        // class to the MockClassLoader's classpool.
+        UseClassPathAdjuster useClassPathAdjuster = new UseClassPathAdjuster() {
+            public Class<? extends Annotation> annotationType() {
+                return UseClassPathAdjuster.class;
+            }
+            public Class<? extends ClassPathAdjuster> value() {
+                return MyClassPathAdjuster.class;
+            }
+        };
+        final MockClassLoader mockClassLoader = new MockClassLoader(new String[0], useClassPathAdjuster );
+        List<MockTransformer> list = new LinkedList<MockTransformer>();
+        list.add(new MainMockTransformer());
+        mockClassLoader.setMockTransformerChain(list);
+
+        // setup custom classloader providing our dynamic class, for MockClassLoader to defer to
+        mockClassLoader.deferTo = new ClassLoader(getClass().getClassLoader()) {
+            @Override
+            public Class<?> loadClass(String name)
+                    throws ClassNotFoundException {
+                if (name.equals(DynamicClassHolder.clazz.getName())) {
+                        return DynamicClassHolder.clazz;
+                }
+                return super.loadClass(name);
+            }
+        };
+
+        // verify that MockClassLoader can successfully load the class
+        Class<?> dynamicTestClass = Class.forName(DynamicClassHolder.clazz.getName(), false, mockClassLoader);
+        Assert.assertNotNull(dynamicTestClass);
+        // .. and that MockClassLoader really loaded the class itself rather
+        // than just providing the class from the deferred classloader
+        assertNotSame(DynamicClassHolder.clazz, dynamicTestClass);
+    }
+
+    // helper class for canFindDynamicClassFromAdjustedClasspath()
+    static class MyClassPathAdjuster implements ClassPathAdjuster {
+        public void adjustClassPath(ClassPool classPool) {
+            classPool.appendClassPath(new ByteArrayClassPath(DynamicClassHolder.clazz.getName(), DynamicClassHolder.classBytes));
+        }
+    }
+
+    // helper class for canFindDynamicClassFromAdjustedClasspath()
+    static class DynamicClassHolder {
+        final static byte[] classBytes;
+        final static Class<?> clazz;
+        static {
+            try {
+                // construct a new class dynamically
+                ClassPool cp = ClassPool.getDefault();
+                final CtClass ctClass = cp.makeClass("my.ABCTestClass");
+                classBytes = ctClass.toBytecode();
+                clazz = ctClass.toClass();
+            } catch (Exception e) {
+                throw new RuntimeException("Problem constructing custom class", e);
+            }
+        }
+    }
 }
-- 
1.8.3.2

